import urlparse
from datetime import datetime, timedelta
from ConfigParser import NoSectionError, DuplicateSectionError

from pyramid.httpexceptions import HTTPFound
from cornice.resource import resource, view
from cornice import Service

import colander
import deform
import transaction

from trumpet.models.sitecontent import SiteText

from trumpet.views.base import RESTViewer

from mslemon.managers.cases import CaseManager
from mslemon.managers.clients import ClientManager
from mslemon.managers.documents import DocumentManager
from mslemon.managers.tickets import TicketManager

from mslemon.views.consultant.base import prepare_base_layout
from mslemon.views.schema import deferred_choices, make_select_widget

from mslemon.models.usergroup import User

from mslemon.util import send_email_through_smtp_server, make_email_message
from mslemon.util import get_regular_users


site_text_service = Service(name='sitetext', path='/rest/sitetext/{id}',
                            description="Site Text Management")

@site_text_service.get()
def get_sitetext(request):
    id = int(request.matchdict['id'])
    db = request.db
    obj = db.query(SiteText).get(id)
    return obj.serialize()

# the "id" is ignored here
# and autogenerated by database backend
@site_text_service.post()
def create_sitetext(request):
    db = request.db
    with transaction.manager:
        st = SiteText()
        st.name = request.POST['name']
        st.content = request.POST['content']
        st.type = 'tutwiki'
        db.add(st)
    st = db.merge(st)
    data = st.serialize()
    data['result'] = 'success'
    return data

@site_text_service.put()
def update_sitetext(request):
    db = request.db
    id = int(request.matchdict['id'])
    with transaction.manager:
        st = db.query(SiteText).get(id)
        if st is not None:
            st.content = request.POST['content']
            st.modified = datetime.now()
            db.add(st)
            result = dict(result='success')
        else:
            result = dict(result='failure')
    st = db.merge(st)
    result['obj'] = st.serialize()
    return result

@site_text_service.delete()
def delete_sitetext(request):
    db = request.db
    id = int(request.matchdict['id'])
    with transaction.manager:
        st = db.query(SiteText).get(id)
        if st is not None:
            db.delete(st)
    return dict(result='success')
    
        
        

class TestViewer(RESTViewer):
    def __init__(self, request):
        super(TestViewer, self).__init__(request)
        self.response = self.request.matchdict
