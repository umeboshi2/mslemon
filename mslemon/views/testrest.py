import urlparse
from datetime import datetime, timedelta
from ConfigParser import NoSectionError, DuplicateSectionError

from pyramid.httpexceptions import HTTPFound
from cornice.resource import resource, view
from cornice import Service

import colander
import deform
import transaction

from trumpet.models.sitecontent import SiteText

from trumpet.views.base import RESTViewer

from mslemon.managers.cases import CaseManager
from mslemon.managers.clients import ClientManager
from mslemon.managers.documents import DocumentManager
from mslemon.managers.tickets import TicketManager

from mslemon.views.consultant.base import prepare_base_layout
from mslemon.views.schema import deferred_choices, make_select_widget
from mslemon.views.base import BaseViewer, make_main_menu

from mslemon.models.usergroup import User

from mslemon.util import send_email_through_smtp_server, make_email_message
from mslemon.util import get_regular_users


        
@resource(collection_path='/rest/sitetext3', path='/rest/sitetext3/{id}',
          permission='admin')
class SiteTextREST(object):
    def __init__(self, request):
        self.request = request
        self.db = self.request.db

    def _query(self):
        return self.db.query(SiteText)
    
    def collection_get(self):
        print "CALLED collection_get--------------------"
        doc_ids = [st.id for st in self._query()]
        return dict(data=[st.serialize() for st in self._query()])

    

    def collection_post(self):
        return self.post()
    

    def get(self):
        id = int(self.request.matchdict['id'])
        return self.db.query(SiteText).get(id).serialize()
    
    # the "id" is ignored here
    # and autogenerated by database backend
    def post(self):
        request = self.request
        db = request.db
        #import pdb ; pdb.set_trace()
        with transaction.manager:
            st = SiteText()
            st.name = request.json['name']
            st.content = request.json['content']
            st.type = 'tutwiki'
            db.add(st)
        st = db.merge(st)
        data = st.serialize()
        data['result'] = 'success'
        return data

    def put(self):
        request = self.request
        db = request.db
        id = int(request.matchdict['id'])
        with transaction.manager:
            st = db.query(SiteText).get(id)
            if st is not None:
                st.content = request.json['content']
                st.modified = datetime.now()
                db.add(st)
                result = dict(result='success')
            else:
                result = dict(result='failure')
        st = db.merge(st)
        result['obj'] = st.serialize()
        return result

    def delete(self):
        request = self.request
        db = request.db
        id = int(request.matchdict['id'])
        with transaction.manager:
            st = db.query(SiteText).get(id)
            if st is not None:
                db.delete(st)
        return dict(result='success')
    
    
class TestViewer(BaseViewer):
    def __init__(self, request):
        super(TestViewer, self).__init__(request)
        #self.response = self.request.matchdict
        self.layout.resources.backbone.need()
        self.layout.main_menu = make_main_menu(self.request)
        self.layout.header = 'Test Backbone and REST'
        self.model = self.request.matchdict['model']
        self.layout.footer = self.model
        template = 'mslemon:templates/test-backbone.mako'
        env = dict(layout=self.layout, view=self)
        content = self.render(template, env)
        self.layout.content = content
        self.layout.resources.test_backbone.need()
        ace = self.layout.resources.ace
        ace.ace.need()
        ace.mode_markdown.need()
        ace.theme_cobalt.need()
